package figbuf_test

import (
	"bytes"
	"fmt"
	"reflect"
	"testing"

	"github.com/figaro-tech/figaro/pkg/figbuf"
)

type SelfMarshaler struct {
	Name string
	Age  uint
}

func (s *SelfMarshaler) MarshalDeterministicBinary(enc *figbuf.Encoder) ([]byte, error) {
	return enc.Encode(s.Name, s.Age)
}

type SelfMarshalerCompose struct {
	Name string
	Age  uint
}

func (s *SelfMarshalerCompose) MarshalDeterministicBinary(enc *figbuf.Encoder) ([]byte, error) {
	return enc.EncodeList(enc.Copy(enc.EncodeString(s.Name)), enc.Copy(enc.EncodeUint(s.Age))), nil
}

type SelfMarshalerNext struct {
	Name string
	Age  uint
}

func (s *SelfMarshalerNext) MarshalDeterministicBinary(enc *figbuf.Encoder) ([]byte, error) {
	next := enc.EncodeNextString(nil, s.Name)
	next = enc.EncodeNextUint(next, s.Age)
	next = enc.EncodeNextList(next, 0)
	return next, nil
}

func ExampleEncoder_EncodeBytesSlice() {
	enc := &figbuf.Encoder{}
	t := [][]byte{{0xff, 0xfe}, {0xcd, 0x03}}
	b := enc.EncodeBytesSlice(t)
	fmt.Printf("% #x\n", b)
	// Output: 0xc6 0x82 0xff 0xfe 0x82 0xcd 0x03
}

func ExampleDeterministicBinaryMarshaler() {
	s := &SelfMarshaler{Name: "Bob", Age: 37}
	enc := &figbuf.Encoder{}
	b, _ := enc.EncodeDeterministicBinaryMarshaler(s)
	fmt.Printf("% #x\n", b)
	// Output: 0xc5 0x83 0x42 0x6f 0x62 0x25
}

func ExampleDeterministicBinaryMarshaler_compose() {
	s := &SelfMarshalerCompose{Name: "Bob", Age: 37}
	enc := &figbuf.Encoder{}
	b, _ := enc.EncodeDeterministicBinaryMarshaler(s)
	fmt.Printf("% #x\n", b)
	// Output: 0xc5 0x83 0x42 0x6f 0x62 0x25
}

func ExampleDeterministicBinaryMarshaler_next() {
	s := &SelfMarshalerNext{Name: "Bob", Age: 37}
	enc := &figbuf.Encoder{}
	b, _ := enc.EncodeDeterministicBinaryMarshaler(s)
	fmt.Printf("% #x\n", b)
	// Output: 0xc5 0x83 0x42 0x6f 0x62 0x25
}

func ExampleEncoder_EncodeBytesSlice_node() {
	enc := &figbuf.Encoder{}
	t := make([][]byte, 0, 17)
	for i := 0; i < 17; i++ {
		t = append(t, bytes.Repeat([]byte{0xff}, 32))
	}
	b := enc.EncodeBytesSlice(t)
	fmt.Printf("% #x\n", b)
	// Output: 0xf9 0x02 0x31 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
}

func BenchmarkDeterministicBinaryMarshaler(b *testing.B) {
	s := &SelfMarshaler{Name: "Bob", Age: 37}
	enc := &figbuf.Encoder{}
	for i := 0; i < b.N; i++ {
		enc.EncodeDeterministicBinaryMarshaler(s)
	}
}

func BenchmarkDeterministicBinaryMarshalerCompose(b *testing.B) {
	// This is the equivalent of
	// List(s.Name, s.Age, List(s.Name, s.Age))
	/*
		return enc.EncodeList(
			enc.EncodeString(s.Name), enc.EncodeUint(s.Age), enc.EncodeList(
				enc.EncodeString(s.Name), enc.EncodeUint(s.Age)
			)
		), nil
	*/
	s := &SelfMarshalerCompose{Name: "Bob", Age: 37}
	enc := &figbuf.Encoder{}
	for i := 0; i < b.N; i++ {
		enc.EncodeDeterministicBinaryMarshaler(s)
	}
}

func BenchmarkDeterministicBinaryMarshalerNext(b *testing.B) {
	// This is the equivalent of
	// List(s.Name, s.Age, List(s.Name, s.Age), List(s.Name, s.Age), List(s.Name, List(s.Name, s.Age)))
	/*
		next := enc.EncodeNextString(nil, s.Name)
		next = enc.EncodeNextUint(next, s.Age)
		idx := uint(len(next))
		next = enc.EncodeNextString(next, s.Name)
		next = enc.EncodeNextUint(next, s.Age)
		next = enc.EncodeNextList(next, idx)
		idx = uint(len(next))
		next = enc.EncodeNextString(next, s.Name)
		next = enc.EncodeNextUint(next, s.Age)
		next = enc.EncodeNextList(next, idx)
		idx = uint(len(next))
		next = enc.EncodeNextString(next, s.Name)
		idxi := uint(len(next))
		next = enc.EncodeNextString(next, s.Name)
		next = enc.EncodeNextUint(next, s.Age)
		next = enc.EncodeNextList(next, idxi)
		next = enc.EncodeNextList(next, idx)
		next = enc.EncodeNextList(next, 0)
		return next, nil
	*/
	s := &SelfMarshalerNext{Name: "Bob", Age: 37}
	enc := &figbuf.Encoder{}
	for i := 0; i < b.N; i++ {
		enc.EncodeDeterministicBinaryMarshaler(s)
	}
}

func BenchmarkEncoder_Encode_bytes(b *testing.B) {
	enc := &figbuf.Encoder{}
	t := []byte{0xff, 0xee}
	for i := 0; i < b.N; i++ {
		enc.Encode(t)
	}
}

func BenchmarkEncoder_Encode_bytesSlice(b *testing.B) {
	enc := &figbuf.Encoder{}
	t := [][]byte{{0xff, 0xfe}, {0xcd, 0x03}}
	for i := 0; i < b.N; i++ {
		enc.Encode(t)
	}
}

func BenchmarkEncoder_EncodeBytes(b *testing.B) {
	enc := &figbuf.Encoder{}
	t := []byte{0xff, 0xee}
	for i := 0; i < b.N; i++ {
		enc.EncodeBytes(t)
	}
}

func BenchmarkEncoder_EncodeBytesSlice(b *testing.B) {
	enc := &figbuf.Encoder{}
	t := [][]byte{{0xff, 0xfe}, {0xcd, 0x03}}
	for i := 0; i < b.N; i++ {
		enc.EncodeBytesSlice(t)
	}
}

func BenchmarkEncoder_EncodeBytesSlice_node(b *testing.B) {
	enc := &figbuf.Encoder{}
	t := make([][]byte, 0, 17)
	for i := 0; i < 17; i++ {
		t = append(t, bytes.Repeat([]byte{0xff}, 32))
	}
	for i := 0; i < b.N; i++ {
		enc.EncodeBytesSlice(t)
	}
}

func TestEncoder_Encode(t *testing.T) {
	type args struct {
		d interface{}
	}
	tests := []struct {
		name    string
		args    args
		wantB   []byte
		wantErr bool
	}{
		// These test cases come from https://github.com/ethereum/wiki/wiki/RLP
		{
			"The string 'dog'",
			args{"dog"},
			[]byte{0x83, 'd', 'o', 'g'},
			false,
		},
		{
			"The list [ 'cat', 'dog' ]",
			args{[]interface{}{"cat", "dog"}},
			[]byte{0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g'},
			false,
		},
		{
			"The empty string ('null')",
			args{""},
			[]byte{0x80},
			false,
		},
		{
			"The empty list",
			args{[]interface{}{}},
			[]byte{0xc0},
			false,
		},
		{
			"The integer 0",
			args{0},
			[]byte{0x80},
			false,
		},
		{
			"The encoded integer 0",
			args{"\x00"},
			[]byte{0x00},
			false,
		},
		{
			"The encoded integer 15",
			args{"\x0f"},
			[]byte{0x0f},
			false,
		},
		{
			"The encoded integer 1024",
			args{"\x04\x00"},
			[]byte{0x82, 0x04, 0x00},
			false,
		},
		{
			"The set theoretical representation of three",
			args{
				[]interface{}{
					[]interface{}{},
					[]interface{}{[]interface{}{}},
					[]interface{}{[]interface{}{}, []interface{}{[]interface{}{}}},
				},
			},
			[]byte{0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0},
			false,
		},
		{
			"The string `Lorem ipsum dolor sit amet, consectetur adipisicing elit`",
			args{"Lorem ipsum dolor sit amet, consectetur adipisicing elit"},
			[]byte{0xb8, 0x38, 'L', 'o', 'r', 'e', 'm', ' ', 'i', 'p', 's', 'u', 'm', ' ', 'd', 'o', 'l', 'o', 'r', ' ', 's', 'i', 't', ' ', 'a', 'm', 'e', 't', ',', ' ', 'c', 'o', 'n', 's', 'e', 'c', 't', 'e', 't', 'u', 'r', ' ', 'a', 'd', 'i', 'p', 'i', 's', 'i', 'c', 'i', 'n', 'g', ' ', 'e', 'l', 'i', 't'},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			enc := &figbuf.Encoder{}
			gotB, err := enc.Encode(tt.args.d)
			if (err != nil) != tt.wantErr {
				t.Errorf("Encoder.Encode() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(gotB, tt.wantB) {
				t.Errorf("Encoder.Encode() = % #x, want % #x", gotB, tt.wantB)
			}
		})
	}
}

func TestEncoder_EncodeBytes(t *testing.T) {
	type args struct {
		d []byte
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{"A few bytes", args{[]byte{0xff, 0xfe}}, []byte{0x82, 0xff, 0xfe}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			enc := &figbuf.Encoder{}
			if got := enc.EncodeBytes(tt.args.d); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Encoder.EncodeBytes() = % #x, want % #x", got, tt.want)
			}
		})
	}
}

func TestEncoder_EncodeBytesSlice(t *testing.T) {
	type args struct {
		dd [][]byte
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{"A few byte slices", args{[][]byte{{0xff, 0xfe}, {0xcd, 0x03}}}, []byte{0xc6, 0x82, 0xff, 0xfe, 0x82, 0xcd, 0x03}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			enc := &figbuf.Encoder{}
			if got := enc.EncodeBytesSlice(tt.args.dd); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Encoder.EncodeBytesSlice() = % #x, want % #x", got, tt.want)
			}
		})
	}
}
