package figbuf_test

import (
	"bytes"
	"fmt"
	"reflect"
	"testing"

	"github.com/figaro-tech/figaro/pkg/figbuf"
)

type SelfMarshaler struct {
	Name string
	Age  uint
}

type ProtoBeater struct {
	Name     string
	Age      uint
	Height   uint
	Weight   uint
	Alive    uint
	Desc     []byte
	Nickname string
	Num      uint
	Flt      uint
	Data     []byte
}

func ExampleSelfMarshaler() {
	s := &SelfMarshaler{Name: "Bob", Age: 37}
	enc := &figbuf.Encoder{}
	b, _ := enc.Encode(s.Name, s.Age)
	fmt.Printf("% #x\n", b)
	// Output: 0xc5 0x83 0x42 0x6f 0x62 0x25
}

func ExampleSelfMarshaler_next() {
	s := &SelfMarshaler{Name: "Bob", Age: 37}
	enc := &figbuf.Encoder{}
	next := enc.EncodeNextString(nil, s.Name)
	next = enc.EncodeNextUint(next, s.Age)
	b := enc.EncodeNextList(next, 0)
	fmt.Printf("% #x\n", b)
	// Output: 0xc5 0x83 0x42 0x6f 0x62 0x25
}

func ExampleSelfMarshaler_protocompare() {
	enc := &figbuf.Encoder{}
	bench := &ProtoBeater{
		Name:     "Tester",
		Age:      20,
		Height:   58,
		Weight:   180,
		Alive:    1,
		Desc:     []byte("Lets benchmark some json and protobuf"),
		Nickname: "Another name",
		Num:      2314,
		Flt:      123451231,
		Data: []byte(`If you’ve ever heard of ProtoBuf you may be thinking that
		the results of this benchmarking experiment will be obvious, JSON < ProtoBuf.
		My interest was in how much they actually differ in practice.
		How do they compare on a couple of different metrics, specifically serialization
		and de-serialization speeds, and the memory footprint of encoding the data.
		I was also curious about how the different serialization methods would
		behave under small, medium, and large chunks of data.`),
	}
	next := enc.EncodeNextString(nil, bench.Name)
	next = enc.EncodeNextUint(next, bench.Age)
	next = enc.EncodeNextUint(next, bench.Height)
	next = enc.EncodeNextUint(next, bench.Weight)
	next = enc.EncodeNextUint(next, bench.Alive)
	next = enc.EncodeNextBytes(next, bench.Desc)
	next = enc.EncodeNextString(next, bench.Nickname)
	next = enc.EncodeNextUint(next, bench.Num)
	next = enc.EncodeNextUint(next, bench.Flt)
	next = enc.EncodeNextBytes(next, bench.Data)
	b := enc.EncodeNextList(next, 0)
	fmt.Printf("% #x\n", b)
	// Output: 0xf9 0x02 0x37 0x86 0x54 0x65 0x73 0x74 0x65 0x72 0x14 0x3a 0x81 0xb4 0x01 0xa5 0x4c 0x65 0x74 0x73 0x20 0x62 0x65 0x6e 0x63 0x68 0x6d 0x61 0x72 0x6b 0x20 0x73 0x6f 0x6d 0x65 0x20 0x6a 0x73 0x6f 0x6e 0x20 0x61 0x6e 0x64 0x20 0x70 0x72 0x6f 0x74 0x6f 0x62 0x75 0x66 0x8c 0x41 0x6e 0x6f 0x74 0x68 0x65 0x72 0x20 0x6e 0x61 0x6d 0x65 0x82 0x09 0x0a 0x84 0x07 0x5b 0xb7 0x5f 0xb9 0x01 0xed 0x49 0x66 0x20 0x79 0x6f 0x75 0xe2 0x80 0x99 0x76 0x65 0x20 0x65 0x76 0x65 0x72 0x20 0x68 0x65 0x61 0x72 0x64 0x20 0x6f 0x66 0x20 0x50 0x72 0x6f 0x74 0x6f 0x42 0x75 0x66 0x20 0x79 0x6f 0x75 0x20 0x6d 0x61 0x79 0x20 0x62 0x65 0x20 0x74 0x68 0x69 0x6e 0x6b 0x69 0x6e 0x67 0x20 0x74 0x68 0x61 0x74 0x0a 0x09 0x09 0x74 0x68 0x65 0x20 0x72 0x65 0x73 0x75 0x6c 0x74 0x73 0x20 0x6f 0x66 0x20 0x74 0x68 0x69 0x73 0x20 0x62 0x65 0x6e 0x63 0x68 0x6d 0x61 0x72 0x6b 0x69 0x6e 0x67 0x20 0x65 0x78 0x70 0x65 0x72 0x69 0x6d 0x65 0x6e 0x74 0x20 0x77 0x69 0x6c 0x6c 0x20 0x62 0x65 0x20 0x6f 0x62 0x76 0x69 0x6f 0x75 0x73 0x2c 0x20 0x4a 0x53 0x4f 0x4e 0x20 0x3c 0x20 0x50 0x72 0x6f 0x74 0x6f 0x42 0x75 0x66 0x2e 0x0a 0x09 0x09 0x4d 0x79 0x20 0x69 0x6e 0x74 0x65 0x72 0x65 0x73 0x74 0x20 0x77 0x61 0x73 0x20 0x69 0x6e 0x20 0x68 0x6f 0x77 0x20 0x6d 0x75 0x63 0x68 0x20 0x74 0x68 0x65 0x79 0x20 0x61 0x63 0x74 0x75 0x61 0x6c 0x6c 0x79 0x20 0x64 0x69 0x66 0x66 0x65 0x72 0x20 0x69 0x6e 0x20 0x70 0x72 0x61 0x63 0x74 0x69 0x63 0x65 0x2e 0x0a 0x09 0x09 0x48 0x6f 0x77 0x20 0x64 0x6f 0x20 0x74 0x68 0x65 0x79 0x20 0x63 0x6f 0x6d 0x70 0x61 0x72 0x65 0x20 0x6f 0x6e 0x20 0x61 0x20 0x63 0x6f 0x75 0x70 0x6c 0x65 0x20 0x6f 0x66 0x20 0x64 0x69 0x66 0x66 0x65 0x72 0x65 0x6e 0x74 0x20 0x6d 0x65 0x74 0x72 0x69 0x63 0x73 0x2c 0x20 0x73 0x70 0x65 0x63 0x69 0x66 0x69 0x63 0x61 0x6c 0x6c 0x79 0x20 0x73 0x65 0x72 0x69 0x61 0x6c 0x69 0x7a 0x61 0x74 0x69 0x6f 0x6e 0x0a 0x09 0x09 0x61 0x6e 0x64 0x20 0x64 0x65 0x2d 0x73 0x65 0x72 0x69 0x61 0x6c 0x69 0x7a 0x61 0x74 0x69 0x6f 0x6e 0x20 0x73 0x70 0x65 0x65 0x64 0x73 0x2c 0x20 0x61 0x6e 0x64 0x20 0x74 0x68 0x65 0x20 0x6d 0x65 0x6d 0x6f 0x72 0x79 0x20 0x66 0x6f 0x6f 0x74 0x70 0x72 0x69 0x6e 0x74 0x20 0x6f 0x66 0x20 0x65 0x6e 0x63 0x6f 0x64 0x69 0x6e 0x67 0x20 0x74 0x68 0x65 0x20 0x64 0x61 0x74 0x61 0x2e 0x0a 0x09 0x09 0x49 0x20 0x77 0x61 0x73 0x20 0x61 0x6c 0x73 0x6f 0x20 0x63 0x75 0x72 0x69 0x6f 0x75 0x73 0x20 0x61 0x62 0x6f 0x75 0x74 0x20 0x68 0x6f 0x77 0x20 0x74 0x68 0x65 0x20 0x64 0x69 0x66 0x66 0x65 0x72 0x65 0x6e 0x74 0x20 0x73 0x65 0x72 0x69 0x61 0x6c 0x69 0x7a 0x61 0x74 0x69 0x6f 0x6e 0x20 0x6d 0x65 0x74 0x68 0x6f 0x64 0x73 0x20 0x77 0x6f 0x75 0x6c 0x64 0x0a 0x09 0x09 0x62 0x65 0x68 0x61 0x76 0x65 0x20 0x75 0x6e 0x64 0x65 0x72 0x20 0x73 0x6d 0x61 0x6c 0x6c 0x2c 0x20 0x6d 0x65 0x64 0x69 0x75 0x6d 0x2c 0x20 0x61 0x6e 0x64 0x20 0x6c 0x61 0x72 0x67 0x65 0x20 0x63 0x68 0x75 0x6e 0x6b 0x73 0x20 0x6f 0x66 0x20 0x64 0x61 0x74 0x61 0x2e
}

func ExampleEncoder_EncodeBytesSlice() {
	enc := &figbuf.Encoder{}
	t := [][]byte{{0xff, 0xfe}, {0xcd, 0x03}}
	b := enc.EncodeBytesSlice(t)
	fmt.Printf("% #x\n", b)
	// Output: 0xc6 0x82 0xff 0xfe 0x82 0xcd 0x03
}

func ExampleEncoder_EncodeBytesSlice_node() {
	enc := &figbuf.Encoder{}
	t := make([][]byte, 0, 17)
	for i := 0; i < 17; i++ {
		t = append(t, bytes.Repeat([]byte{0xff}, 32))
	}
	b := enc.EncodeBytesSlice(t)
	fmt.Printf("% #x\n", b)
	// Output: 0xf9 0x02 0x31 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xa0 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
}

func BenchmarkSelfMarshaler(b *testing.B) {
	s := &SelfMarshaler{Name: "Bob", Age: 37}
	enc := &figbuf.Encoder{}
	for i := 0; i < b.N; i++ {
		enc.Encode(s.Name, s.Age)
	}
}

func BenchmarkSelfMarshalerNext(b *testing.B) {
	s := &SelfMarshaler{Name: "Bob", Age: 37}
	enc := &figbuf.Encoder{}
	var next []byte
	for i := 0; i < b.N; i++ {
		next = enc.EncodeNextString(nil, s.Name)
		next = enc.EncodeNextUint(next, s.Age)
		next = enc.EncodeNextList(next, 0)
	}
}

func BenchmarkEncoder_EncodeString_protocompare(b *testing.B) {
	enc := &figbuf.Encoder{}
	bench := &ProtoBeater{
		Name:     "Tester",
		Age:      20,
		Height:   58,
		Weight:   180,
		Alive:    1,
		Desc:     []byte("Lets benchmark some json and protobuf"),
		Nickname: "Another name",
		Num:      2314,
		Flt:      123451231,
		Data: []byte(`If you’ve ever heard of ProtoBuf you may be thinking that
		the results of this benchmarking experiment will be obvious, JSON < ProtoBuf.
		My interest was in how much they actually differ in practice.
		How do they compare on a couple of different metrics, specifically serialization
		and de-serialization speeds, and the memory footprint of encoding the data.
		I was also curious about how the different serialization methods would
		behave under small, medium, and large chunks of data.`),
	}
	var next []byte
	for i := 0; i < b.N; i++ {
		next = enc.EncodeNextString(nil, bench.Name)
		next = enc.EncodeNextUint(next, bench.Age)
		next = enc.EncodeNextUint(next, bench.Height)
		next = enc.EncodeNextUint(next, bench.Weight)
		next = enc.EncodeNextUint(next, bench.Alive)
		next = enc.EncodeNextBytes(next, bench.Desc)
		next = enc.EncodeNextString(next, bench.Nickname)
		next = enc.EncodeNextUint(next, bench.Num)
		next = enc.EncodeNextUint(next, bench.Flt)
		next = enc.EncodeNextBytes(next, bench.Data)
		next = enc.EncodeNextList(next, 0)
	}
}

func BenchmarkEncoder_Encode_bytes(b *testing.B) {
	enc := &figbuf.Encoder{}
	t := []byte{0xff, 0xee}
	for i := 0; i < b.N; i++ {
		enc.Encode(t)
	}
}

func BenchmarkEncoder_Encode_bytesSlice(b *testing.B) {
	enc := &figbuf.Encoder{}
	t := [][]byte{{0xff, 0xfe}, {0xcd, 0x03}}
	for i := 0; i < b.N; i++ {
		enc.Encode(t)
	}
}

func BenchmarkEncoder_EncodeBytes(b *testing.B) {
	enc := &figbuf.Encoder{}
	t := []byte{0xff, 0xee}
	for i := 0; i < b.N; i++ {
		enc.EncodeBytes(t)
	}
}

func BenchmarkEncoder_EncodeBytesSlice(b *testing.B) {
	enc := &figbuf.Encoder{}
	t := [][]byte{{0xff, 0xfe}, {0xcd, 0x03}}
	for i := 0; i < b.N; i++ {
		enc.EncodeBytesSlice(t)
	}
}

func BenchmarkEncoder_EncodeBytesSlice_node(b *testing.B) {
	enc := &figbuf.Encoder{}
	t := make([][]byte, 0, 17)
	for i := 0; i < 17; i++ {
		t = append(t, bytes.Repeat([]byte{0xff}, 32))
	}
	for i := 0; i < b.N; i++ {
		enc.EncodeBytesSlice(t)
	}
}

func TestEncoder_Encode(t *testing.T) {
	type args struct {
		d interface{}
	}
	tests := []struct {
		name    string
		args    args
		wantB   []byte
		wantErr bool
	}{
		// These test cases come from https://github.com/ethereum/wiki/wiki/RLP
		{
			"The string 'dog'",
			args{"dog"},
			[]byte{0x83, 'd', 'o', 'g'},
			false,
		},
		{
			"The list [ 'cat', 'dog' ]",
			args{[]interface{}{"cat", "dog"}},
			[]byte{0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g'},
			false,
		},
		{
			"The empty string ('null')",
			args{""},
			[]byte{0x80},
			false,
		},
		{
			"The empty list",
			args{[]interface{}{}},
			[]byte{0xc0},
			false,
		},
		{
			"The integer 0",
			args{0},
			[]byte{0x80},
			false,
		},
		{
			"The encoded integer 0",
			args{"\x00"},
			[]byte{0x00},
			false,
		},
		{
			"The encoded integer 15",
			args{"\x0f"},
			[]byte{0x0f},
			false,
		},
		{
			"The encoded integer 1024",
			args{"\x04\x00"},
			[]byte{0x82, 0x04, 0x00},
			false,
		},
		{
			"The set theoretical representation of three",
			args{
				[]interface{}{
					[]interface{}{},
					[]interface{}{[]interface{}{}},
					[]interface{}{[]interface{}{}, []interface{}{[]interface{}{}}},
				},
			},
			[]byte{0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0},
			false,
		},
		{
			"The string `Lorem ipsum dolor sit amet, consectetur adipisicing elit`",
			args{"Lorem ipsum dolor sit amet, consectetur adipisicing elit"},
			[]byte{0xb8, 0x38, 'L', 'o', 'r', 'e', 'm', ' ', 'i', 'p', 's', 'u', 'm', ' ', 'd', 'o', 'l', 'o', 'r', ' ', 's', 'i', 't', ' ', 'a', 'm', 'e', 't', ',', ' ', 'c', 'o', 'n', 's', 'e', 'c', 't', 'e', 't', 'u', 'r', ' ', 'a', 'd', 'i', 'p', 'i', 's', 'i', 'c', 'i', 'n', 'g', ' ', 'e', 'l', 'i', 't'},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			enc := &figbuf.Encoder{}
			gotB, err := enc.Encode(tt.args.d)
			if (err != nil) != tt.wantErr {
				t.Errorf("Encoder.Encode() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(gotB, tt.wantB) {
				t.Errorf("Encoder.Encode() = % #x, want % #x", gotB, tt.wantB)
			}
		})
	}
}

func TestEncoder_EncodeBytes(t *testing.T) {
	type args struct {
		d []byte
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{"A few bytes", args{[]byte{0xff, 0xfe}}, []byte{0x82, 0xff, 0xfe}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			enc := &figbuf.Encoder{}
			if got := enc.EncodeBytes(tt.args.d); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Encoder.EncodeBytes() = % #x, want % #x", got, tt.want)
			}
		})
	}
}

func TestEncoder_EncodeBytesSlice(t *testing.T) {
	type args struct {
		dd [][]byte
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{"A few byte slices", args{[][]byte{{0xff, 0xfe}, {0xcd, 0x03}}}, []byte{0xc6, 0x82, 0xff, 0xfe, 0x82, 0xcd, 0x03}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			enc := &figbuf.Encoder{}
			if got := enc.EncodeBytesSlice(tt.args.dd); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Encoder.EncodeBytesSlice() = % #x, want % #x", got, tt.want)
			}
		})
	}
}
